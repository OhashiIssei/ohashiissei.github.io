<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas</title>
    <style>
      




      body {
        margin: 0;
        overflow: hidden;
        /* background: #ccc; */
        touch-action: none
      }



      /* ツールバーのデザイン */

      .toolbar{
        width: 100%;
        height: 75px;
        background: #ccc;
        padding: 5px;
        display: flex;
        /* align-items: flex-end; */;
      }



      .leftbar {
        width: 150px;
        flex:1
      }

      .moodbar {
        width: 150px;
        display: flex;
        flex:1
      }

      .rightbar {
        width: 150px;
        display: flex;
        flex:1
      }

      input[type="color"], button {
        width: 90%;
        margin: 0 auto;
        display:white;
      }

      input[type="range"] {
        width: 70%;
      }

      /* input[type="erasersize"] {
        width: 70%;
      } */

      span {
      position: relative;
      bottom: 5px;
      }

      /* カーソルデザイン変更 */

      .write{
        cursor: pointer
      }

      .line{
        cursor: crosshair
      }

      .eraser{
        cursor:grab
      }

      .select{
        cursor:crosshair
      }


      /* レイヤーのデザイン */

      /* .layer{
      position:relateve
      } */
      canvas{position:absolute}
      .ui2-layer{ z-index: 5}
      .ui-layer{ z-index: 4}
      .active-layer{ z-index: 3}
      .vesible-layer{ z-index: 2}
      .back-layer{ z-index: 1}







      </style>

  </head>
  <body>
   
    

    <div class="toolbar">
      <div class ="leftbar">
        <input type="color" aria-label="select pen color" value="#ffffff">
        <input class = "pensize" type="range" min="2" max="50" value="10" aria-label="select pen size">
          <span class="pensizeOutput">10</span>
          <span >ペン</span>
        <input class = "erasersize" type="range" min="2" max="500" value="30" aria-label="select pen size">
          <span class="erasersizeOutput">30</span>
          <span >消し</span>
      </div>
      <div class ="moodbar">
        <button class="write">手書き</button>
        <button class="line">図形</button>
        <button class="eraser">消しゴム</button>
        <button class="select">選択</button>
      </div>
      <div class ="rightbar">
        <button class="clear">全消去</button>
        <button class="back">戻る</button>
        <button class="undo">取り消す</button>
      </div>
    </div>

    <div class="layers">
      <canvas class="ui2-layer"></canvas>
      <canvas class="ui-layer"></canvas>
      <canvas class="active-layer"></canvas>
      <canvas class="visible-layer"></canvas>
      <canvas class="back-layer"></canvas>
    </div>
    

    
    
    <script>


      const canvases = document.querySelectorAll('canvas');
      const layers= document.querySelector('.layers');
      const ui2Layer = document.querySelector('.ui2-layer');
      const uiLayer = document.querySelector('.ui-layer');
      const activeLayer = document.querySelector('.active-layer');
      const visibleLayer = document.querySelector('.visible-layer');
      const backLayer = document.querySelector('.back-layer');
      const ui2Ctx = ui2Layer.getContext('2d');
      const uiCtx = uiLayer.getContext('2d');
      const activeCtx = activeLayer.getContext('2d');
      const visibleCtx = visibleLayer.getContext('2d');
      const backCtx = backLayer.getContext("2d")

      ui2Ctx.name = "ui2Ctx"
      uiCtx.name = "uiCtx"
      activeCtx.name =  "activeCtx"
      visibleCtx.name = "visibleCtx"
      backCtx.name = "backCtx"

      const menuHeight = 85
      const width = window.innerWidth;
      const height = window.innerHeight;

      for(let i=0;i<canvases.length;i++){
        canvases[i].width = width
        canvases[i].height = height// /3 * (i+1)
        // ツールバーの分をずらす
        canvases[i].getContext('2d').translate(0,-menuHeight)
        canvases[i].getContext('2d').lineJoin = 'round';
        canvases[i].getContext('2d').lineCap = 'round';
      }

      activeCtx.clearRect(0,0,width,height)

      visibleCtx.fillStyle = 'rgb(0,0,0)';
      visibleCtx.fillRect(0,0,width,height);


      const colorPicker = document.querySelector('input[type="color"]');
      const sizePicker = document.querySelector('.pensize');
      const pensizeOutput = document.querySelector('.pensizeOutput');
      const eraserSizePicker = document.querySelector('.erasersize');
      const erasersizeOutput = document.querySelector('.erasersizeOutput');

      let selectedPathes =[]





      sizePicker.value = localStorage.getItem('size')
      pensizeOutput.textContent = sizePicker.value
      eraserSizePicker.value = localStorage.getItem('eraserSize')
      erasersizeOutput.textContent = eraserSizePicker.value

      colorPicker.value = localStorage.getItem('color')


      // ||  ボタンの実装

      sizePicker.addEventListener('input', function(){
        pensizeOutput.textContent = sizePicker.value
        localStorage.setItem('size',sizePicker.value)
      });
      eraserSizePicker.addEventListener('input', function(){
        erasersizeOutput.textContent = eraserSizePicker.value
        localStorage.setItem('eraserSize',eraserSizePicker.value)
      });

      colorPicker.addEventListener('chenge', function(){
        localStorage.setItem('color',colorPicker.value)
      });

      const Btns = document.querySelectorAll('button');

      let pressed = false

      let mode = "write"

      // clearBtn.addEventListener('click',zensyoukyo)

      for(let i=0;i<Btns.length-3;i++){
        Btns[i].addEventListener("click",setMode)
        }

      function setMode(e){
        nonActiveAll()
        mode = e.target.getAttribute("class")
        layers.setAttribute("class",mode)
        console.log("modeを"+mode+"に切り替えました")
      }

      // Btns[3].removeEventListener("click",setMode)
      // Btns[3].addEventListener("click",Kirikae)

      //カーソルデザイン変更

      // function Kirikae(e){
      //   if(mode!=="sentaku"){
      //     mode="sentaku"
      //     canvas.setAttribute("class",mode)
      //     e.target.textContent = "選択"
      //   }else{
      //     mode ="idou"
      //     canvas.setAttribute("class",mode)
      //     e.target.textContent =  "移動"
      //   }
      // }

      // ||ショートカットキー

      window.addEventListener("keydown",function(e){
        console.log(e.key)
        switch(e.key){
          case "z":Btns[0];
          break;
          case "x":Btns[1];
          break;
          case "c":Btns[2];
          break;
          case "a":Btns[3];
          break;
          case "s":Btns[4];
          break;
          case "d":Btns[5];
          break;
          case "f":Btns[6];
          break;
        }
      })

      // Btn[i].textContent += " (Z)"
      // undoBtn.textContent += " (X)"
      // clearBtn.textContent += " (C)"

      // 関数集
      function degToRad(degrees) {
        return degrees * Math.PI / 180;
      };

      function conj(p1){
        return [p1[0],-p1[1]]
      }

      function sum(p1,p2){
        return [p1[0]+p2[0],p1[1]+p2[1]]
      }

      function diff(p1,p2){
        return [p1[0]-p2[0],p1[1]-p2[1]]
      }

      function times(p1,p2){
        return [p1[0]*p2[0]-p1[1]*p2[1],p1[0]*p2[1]+p1[1]*p2[0]]
      }

      function dev(p1,p2){
        return [times(p1,conj(p2))[0]/(distance(p2,[0,0])**2),times(p1,conj(p2))[1]/(distance(p2,[0,0])**2)]
      }

      function innerProduct(p1,p2){
        return p1[0]*p2[0]+p1[1]*p2[1]
      }

      function crossProduct(p1,p2){
        return p1[0]*p2[1]-p1[1]*p2[0]
      }


      function distance(p1,p2){
        return Math.hypot(p1[0]-p2[0],p1[1]-p2[1])
      }

      function midPoint(p1,p2){
        return [(p1[0]+p2[0])/2,(p1[1]+p2[1])/2]
      }




      function norm(p){
        return Math.sqrt(p[0]**2+p[1]**2)
      }

      function denotedByComplex(p0,p1,p2){
        return dev(diff(p0,p1),diff(p2,p1))
      }







      // || 全消去

      let massara = true

      Btns[4].addEventListener("click",function(e){
        e.preventDefault();
        nonActiveAll()
        visibleCtx.clearRect(0,0,width,height)
        visibleCtx.fillStyle = 'rgb(0,0,0)';
        visibleCtx.fillRect(0,0,width,height);
        visibleCtx.pathes = []
        console.log("全消去")
      });

      // ||戻る

      Btns[5].addEventListener("click",function(e){
        e.preventDefault();
        nonActiveAll()
        visibleCtx.restore()
        console.log("戻る")
      })

      // ||取り消す

      Btns[6].addEventListener("click",function(e){
        e.preventDefault();
        nonActiveAll()
        console.log("取り消す")
      })

      // ||マウス座標データの蓄積

      let curX
      let curY

      // function addStrokeP(e){
      //   curX = (window.Event) ? e.pageX : e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
      //   curY = (window.Event) ? e.pageY : e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
      // }



      const emptyPath = new Path2D()

      let path
      let points = []
      let inP = new DOMPoint()
      let outP = new DOMPoint()
      let dx = 0
      let dy = 0

      let minX
      let minY
      let maxX
      let maxY


      // || 'pointerdown'の振る舞い
      layers.addEventListener('pointerdown', function(e){
        e.preventDefault();
        pressed = true
        inP.x = minX = maxX = e.x;
        inP.y = minY = maxY = e.y;
        switch(true){
        case mode==="write":
          path = new Path2D();
          path.addId(colorPicker.value,sizePicker.value,[[e.x,e.y]])
          path.moveTo(e.x,e.y)
          break;
          
        case mode==="line":
          activeCtx.lineWidth = sizePicker.value
          activeCtx.strokeStyle  = colorPicker.value
          inP.x = tenHosei([e.x,e.y])[0]
          inP.y = tenHosei([e.x,e.y])[1]
          break

        case mode==="eraser":
          activeCtx.beginPath()
          activeCtx.fillStyle = "white"
          activeCtx.arc(e.x,e.y,eraserSizePicker.value/2,0,2*Math.PI)
          activeCtx.fill()
          for(let i=0;i<visibleCtx.pathes.length;i++){
            backCtx.lineWidth = Number(eraserSizePicker.value)+Number(sizePicker.value);;
            if(backCtx.isPointInStroke(visibleCtx.pathes[i],e.x,e.y-menuHeight)){
              visibleCtx.delete(visibleCtx.pathes[i])
              i--
            }
          }
          break

        case mode==="select":
          break;

        case mode==="selected":
          activeImage = activeCtx.getImageData(0,0,width,height)
          uiImage = uiCtx.getImageData(0,0,width,height)
          backCtx.lineWidth = nagenawaWidth+Number(sizePicker.value);
          for(let i=0;i<activeCtx.pathes.length;i++){
            if(backCtx.isPointInStroke(activeCtx.pathes[i],e.x,e.y-menuHeight)){
              break
            }
            if(i===activeCtx.pathes.length-1){
              nonActiveAll()
              mode = "select"
              console.log(mode+" modeになりました")
            }
          }
          break

        case mode==="transform":
          switch(true){
          case uiCtx.isPointInPath(uiCtx.pathes[5],e.x,e.y-menuHeight,"nonzero"):
            uiCtx.clearRect(0,0,width,height)
            ui2Ctx.draw(uiCtx.pathes[5])
            ui2Image = ui2Ctx.getImageData(0,0,width,height)
            uiCtx.pathes.pop()
            for(let i =0;i<uiCtx.pathes.length;i++){
              uiCtx.display(uiCtx.pathes[i])
            }
            // uiCtx.delete(uiCtx.pathes[5])
            
            // uiImage = uiCtx.getImageData(0,0,width,height)
            // activeImage = activeCtx.getImageData(0,0,width,height)
            // visibleImage = visibleCtx.getImageData(0,0,width,height)
            // visibleCtx.putImageData(visibleImage,0,0)
            // activeCtx.putImageData(activeImage,0,0)
            // uiCtx.putImageData(uiImage,0,0)
            // ui2Ctx.putImageData(ui2Image,0,0)

            mode ="center"
            break;
          case uiCtx.isPointInPath(uiCtx.pathes[1],e.x,e.y-menuHeight,"nonzero"):
            activeCtx.clearRect(0,0,width,height)
            activeCtx.pathes = []
            uiCtx.clearRect(0,0,width,height)
            uiCtx.pathes = []
            console.log("activeCtx.pathesを全て消しました。")
            mode = "select"
            break;
          case uiCtx.isPointInPath(uiCtx.pathes[2],e.x,e.y-menuHeight,"nonzero"):
            mode = "rotate"
            break;
          case uiCtx.isPointInPath(uiCtx.pathes[3],e.x,e.y-menuHeight,"nonzero"):
            mode = "scale"
            break;
          case uiCtx.isPointInPath(uiCtx.pathes[4],e.x,e.y-menuHeight,"nonzero"):
            activeImage = activeCtx.getImageData(0,0,width,height)
            uiImage = uiCtx.getImageData(0,0,width,height)
            for(let i=0;i<activeCtx.pathes.length;i++){
              const copy = activeCtx.pathes[i]
              copy.id = id;
              id++;
              visibleCtx.draw(copy)
            }
            mode = "copy"
            break;
          case uiCtx.isPointInPath(uiCtx.pathes[0],e.x,e.y-menuHeight,"nonzero"):
            activeImage = activeCtx.getImageData(0,0,width,height)
            uiImage = uiCtx.getImageData(0,0,width,height)
            mode ="translation"
            break;
          default:
            nonActiveAll()
            mode = "select"
          }
          console.log(mode+" modeになりました")
          break;
        }
        console.log(mode+"での描き始め")
        console.log(backCtx.pathes.length+", "+visibleCtx.pathes.length+", "+activeCtx.pathes.length+", "+uiCtx.pathes.length+", "+ui2Ctx.pathes.length)
      });

      let activeImage
      let uiImage
      let ui2Image
      let complex = []

      let timer1
      let w
      let h
      let s
      let center


      // Shape検出のルール

      function chengeToShape(e) {
        const d = distance([inP.x,inP.y],[e.x,e.y])
        w = maxX-minX
        h = maxY-minY
        s = Math.sqrt(w**2+h**2)
        center = midPoint([minX,minY],[maxX,maxY])
        console.log(d+","+w+","+h+","+s)
        switch(true){
          case d/s>0.9:
            activeCtx.clearRect(0,0,width,height)
            activeCtx.beginPath()
            activeCtx.moveTo(inP.x,inP.y)
            activeCtx.lineTo(e.x,e.y)
            activeCtx.stroke()
            mode="line";
            console.log(mode+" modeになりました")
            break;
          case d/s<0.1:
            path = new Path2D()
            activeCtx.clearRect(0,0,width,height)
            path.ellipse(center[0],center[1],w/2,h/2,0,0,2*Math.PI)
            activeCtx.draw(path)
            inP.x =e.x;
            inP.y =e.y;
            mode="ellipse";
            console.log(mode+" modeになりました")
            break;
          case inP.x<minX+h/10||e.x<minX+h/10:
            const p = [inP.x,inP.y]
            const q = [e.x,e.y]
            const m = midPoint(p,q)
            let i = 0
            while(path.points[i][0]>m[0]){i++}
            const r = midPoint(path.points[i-1],path.points[i])
            const c = symmetryPointAbout(r,m)
            path = new Path2D()
            path.moveTo(p[0],p[1])
            path.quadraticCurveTo(c[0],c[1],q[0],q[1])
            activeCtx.clearRect(0,0,width,height)
            // path.addPath(colorPicker.value,sizePicker.value,[p,r,q])
            activeCtx.draw(path)
            inP.x =e.x;
            inP.y =e.y;
            mode="curve";
            console.log(mode+" modeになりました")
          // default:
          //   activeCtx.clearRect(0,0,width,height)
          //   path = smoothedPath(path,3)
          //   activeCtx.draw(path)
          //   mode="curve";
          //   console.log(mode+" modeになりました")
        }
      }

      function symmetryPointAbout(p0,p){
        return diff([2*p0[0],2*p0[1]],p)
      }

      function smoothedPath(path,level) {


        
        const n = path.points.length
        const l = Math.floor(n/level)
        console.log(n)
        console.log(l)
        newpath = new Path2D();
        newpath.addId(path.strokeStyle,path.lineWidth,path.points)
        newpath.moveTo(path.points[0][0],path.points[0][1])
        let ancP = path.points[0]
        for(let i=1;i*l<n;i++){
          const p1 = path.points[(i-1)*l]
          const p2 = path.points[Math.min(i*l,n-1)]
          ancP = symmetryPointAbout(p1,ancP)
          newpath.quadraticCurveTo(ancP[0],ancP[1],p2[0],p2[1])
          
          // writeTo(,path.points[(i-1)*l],path.points)
          console.log(i+", "+(i-1)*l+", "+i*l)
        }
        return newpath
      }

      function displayCurvatureRadius(points) {
        const level = 10
        const n = points.length
        if(n>=level+3){
          while(points.length>n-level){
            let newpoints = []
            for(let i=0;i<points.length-1;i++){
              newpoints.push(midPoint(points[i],points[i+1]))
            }
            points = newpoints
          }
          const r = curvatureRadius(points[0],points[1],points[2])
          activeCtx.fillStyle = colorPicker.value
          activeCtx.fillRect(n-3,menuHeight*2,3,100/r)
        }
      }

      function curvatureRadius(p0,p1,p2){
        const a = diff(p0,p1);
        const b = diff(p2,p1);
        const cos = innerProduct(a,b)/norm(a)/norm(b)
        const theta = Math.acos(cos)
        const d = distance(p0,p2);
        const sgn =  Math.sign(crossProduct(a,b))
        const r = d/(2*Math.sin(theta))
        // console.log(r*sgn/d)
        return r*sgn/d
      }







      // || 'pointermove'の振る舞い
      layers.addEventListener('pointermove', function(e){
        e.preventDefault();
        minX =  Math.min(minX,e.x)
        minY =  Math.min(minY,e.y)
        maxX =  Math.max(maxX,e.x)
        maxY =  Math.max(maxY,e.y)
        dx = e.x - inP.x 
        dy = e.y - inP.y
        if(pressed){
          console.log(mode+"で書いている")
          switch(true){
          case mode==="write":
            clearTimeout(timer1)
            path.writeTo(path.points[0],[e.x,e.y])
            path.points.unshift([e.x,e.y])
            activeCtx.display(path)
            timer1 = setTimeout(()=>{chengeToShape(e)},200)
            setTimeout(()=>{displayCurvatureRadius(path.points)})
            break
          case mode==="line":
            activeCtx.clearRect(0,0,width,height)
            activeCtx.beginPath()
            activeCtx.moveTo(inP.x,inP.y)
            activeCtx.lineTo(e.x,e.y)
            activeCtx.stroke()
            break

          case mode==="eraser":
            activeCtx.clearRect(0,0,width,height)
            activeCtx.fillStyle = "white"
            activeCtx.beginPath()
            activeCtx.arc(e.x,e.y,eraserSizePicker.value/2,0,2*Math.PI)
            activeCtx.fill()
            for(let i=0;i<visibleCtx.pathes.length;i++){
              backCtx.lineWidth = Number(eraserSizePicker.value)+Number(sizePicker.value);
              if(backCtx.isPointInStroke(visibleCtx.pathes[i],e.x,e.y-menuHeight,"nonzero")){
                visibleCtx.delete(visibleCtx.pathes[i])
                i--
              }
            }
            break

          case mode==="select":
            for(let i=0;i<visibleCtx.pathes.length;i++){
              backCtx.lineWidth = nagenawaWidth+Number(sizePicker.value);
              if(backCtx.isPointInStroke(visibleCtx.pathes[i],e.x,e.y-menuHeight,"nonzero")){
                visibleCtx.pathes[i].active()
                i--
              }
            }
            break

          case mode==="selected":
            if(distance([e.x,e.y],[inP.x,inP.y])>=5){
              mode = "translation"
              console.log(mode+" modeになりました")
            }
            break
          
          case mode==="translation"||mode==="copy":
            activeCtx.clearRect(0,0,width,height) 
            activeCtx.putImageData(activeImage,dx,dy)    
            uiCtx.clearRect(0,0,width,height)
            uiCtx.putImageData(uiImage,dx,dy)     
            break

          case mode==="center":
            ui2Ctx.clearRect(0,0,width,height)
            ui2Ctx.putImageData(ui2Image,dx,dy)
            break

          case mode==="scale"||mode==="rotate"||mode==="ellipse"||mode==="curve":
            let p = [e.x,e.y]
            complex = denotedByComplex(p,center,[inP.x,inP.y])
            if(mode==="scale"){
              complex = [norm(complex),0]
            }else if(mode==="rotate"){
              complex = [complex[0]/norm(complex),complex[1]/norm(complex)];
            }
            // else if(mode==="curve"){

            // }
            activeCtx.transformedPathes(center,complex)
            uiCtx.transformedPathes(center,complex)
            break;
          }
        }
      });

      let nagenawaWidth = 10

      // || 'pointerup'の振る舞い
      layers.addEventListener('pointerup', function(e){
        e.preventDefault();
        pressed = false
        dx = e.x - inP.x 
        dy = e.y - inP.y
        const m = new DOMMatrix();
            m.a = 1; m.b = 0;
            m.c = 0; m.d = 1;
            m.e = dx ; m.f = dy;
        console.log(mode+"を描きおわる")
        switch(true){
          case mode==="write":
            clearTimeout(timer1)
            nonActiveAll()
            visibleCtx.draw(path)
            mode ="write";
            console.log(mode+" modeに戻りました")
            break;
          case mode==="line":
            outX = tenHosei([e.x,e.y])[0]
            outY = tenHosei([e.x,e.y])[1]
            path = new Path2D();
            path.moveTo(inP.x,inP.y)
            path.lineTo(outX,outY)
            path.addId(colorPicker.value,sizePicker.value,[[inP.x,inP.y],[outX,outY]])
            nonActiveAll()
            visibleCtx.draw(path)
            hoseitenGroup.push([inP.x,inP.y],[outX,outY])
            mode="write";
            console.log(mode+" modeに戻りました")
            break;

          case mode==="ellipse"||mode==="curve":
            path.addId(colorPicker.value,sizePicker.value,[[minX,minY],[maxX,maxY]])//ポイント情報が意味を成していない
            activeCtx.transformPathes(center,complex)
            activeCtx.pathes[0].lineWidth = sizePicker.value
            // nonActiveAll()
            mode="transform"
            createTransformUi()
            break;

          case mode==="eraser":
            activeCtx.clearRect(0,0,width,height);
            break

          case mode==="select":
            console.log(activeCtx.pathes)
            if(activeCtx.pathes.length!==0){
              mode = "selected"
              console.log(mode+" modeになりました")
            }else{
              mode = "write"
              console.log(mode+" modeになりました")
            }
            break

          case mode==="selected":
            createTransformUi()
            mode = "transform"
            console.log(mode+" modeになりました")
            break


          case mode==="scale"||mode==="rotate":
            activeCtx.transformPathes(center,complex)
            uiCtx.transformPathes(center,complex)
            mode = "transform"
            console.log(mode+" modeに戻りました")
            break

          case mode==="center":
            uiCtx.draw(ui2Ctx.pathes[0].transformedByMatrix(m))
            ui2Ctx.clearRect(0,0,width,height)
            ui2Ctx.pathes = []
            center = [center[0]+dx,center[1]+dy]
            mode ="transform"
            console.log(mode+" modeに戻りました")
            break;
          
          case mode==="translation"||mode==="copy":
            for(let i=0;i<activeCtx.pathes.length;i++){
              const newpath = activeCtx.pathes[i].transformedByMatrix(m)
              activeCtx.pathes.splice(i,1,newpath)
            }
            if(uiCtx.pathes.length!==0){
              for(let i=0;i<uiCtx.pathes.length;i++){
                const newpath = uiCtx.pathes[i].transformedByMatrix(m)
                uiCtx.pathes.splice(i,1,newpath)
                uiCtx.display(newpath)
              }
              // createTransformUi()
              center = [center[0]+dx,center[1]+dy]
              mode = "transform"
              console.log(mode+" modeになりました")
            }else{
              mode = "selected"
              console.log(mode+" modeになりました")
            }
            break    
          

        }
        console.log(backCtx.pathes.length+", "+visibleCtx.pathes.length+", "+activeCtx.pathes.length+", "+uiCtx.pathes.length+", "+ui2Ctx.pathes.length)
      });




      // || "CanvasRenderingContext2D" のプロパティとメソッドを追加する

      backCtx.pathes = []
      visibleCtx.pathes = []
      activeCtx.pathes = []
      uiCtx.pathes = []
      ui2Ctx.pathes = []


      CanvasRenderingContext2D.prototype.display = function(path){
        this.lineWidth = path.lineWidth
        this.strokeStyle = path.strokeStyle
        this.fillStyle = path.fillStyle
        this.stroke(path)
      }

      CanvasRenderingContext2D.prototype.draw = function(path){
        this.display(path)
        this.pathes.push(path)
        console.log(path.id + "を" + this.name + "に draw しました")
      }



      CanvasRenderingContext2D.prototype.delete =  function(path){
        const index = this.pathes.indexOf(path)
        this.pathes.splice(index,1)
        this.clearRect(0,0,width,height)
        this.fillStyle = 'rgb(0,0,0)';
        this.fillRect(0,0,width,height);
        for(let i=0;i<this.pathes.length;i++){
          this.display(this.pathes[i])
        }
        console.log(path.id+" を "+this.name+" から消しました。")
      }

      CanvasRenderingContext2D.prototype.transformedPathes = function(center,complex){
        const r = new DOMMatrix();
        r.a = 1; r.b = 0;
        r.c = 0; r.d = 1;
        r.e = -center[0]; r.f = -center[1];
        const p = new DOMMatrix();
        p.a = complex[0]; p.b = complex[1];
        p.c = -complex[1]; p.d = complex[0];
        p.e = center[0]; p.f = center[1];
        this.clearRect(0,0,width,height)
        let pathes =[]
        for(let i=0;i<this.pathes.length;i++){
          const newpath = this.pathes[i].transformedByMatrix(r).transformedByMatrix(p)
          pathes.push(newpath)
          this.display(newpath)
        }
        // console.log(center+"を中心にして" + this.name +"のPathesに"+complex+"をかけたものを描いています。")
        return pathes
      }


      CanvasRenderingContext2D.prototype.transformPathes = function(center,complex){
        const r = new DOMMatrix();
        r.a = 1; r.b = 0;
        r.c = 0; r.d = 1;
        r.e = -center[0]; r.f = -center[1];
        const p = new DOMMatrix();
        p.a = complex[0]; p.b = complex[1];
        p.c = -complex[1]; p.d = complex[0];
        p.e = center[0]; p.f = center[1];
        this.clearRect(0,0,width,height)
        // let pathes =[]
        for(let i=0;i<this.pathes.length;i++){
          const newpath = this.pathes[i].transformedByMatrix(r).transformedByMatrix(p)
          // pathes.push(newpath)
          this.pathes.splice(i,1,newpath)
          this.display(newpath)
        }
        console.log(center+"を中心にして" + this.name +"のPathesを"+complex+"をかけたものに置き換えました")
      }

      // CanvasRenderingContext2D.prototype.transformPathes = function(center,complex){
      //   for(let i=0;i<this.pathes.length;i++){
      //     const newpath = this.transformedPathes(center,complex)[i]
          
      //   }
      // }




      // "Path2D"ののプロバティとメソッドを追加。

      let id = 1

      Path2D.prototype.addId =  function(strokeStyle,lineWidth,points){
        this.strokeStyle = strokeStyle
        this.lineWidth = lineWidth
        this.points = points
        this.id = id
        id++
        console.log("id : "+ this.id +" を登録しました")
        console.dir(this)
      }

      Path2D.prototype.active =  function(){
        activeCtx.strokeStyle = "rgba(255, 173, 105, 50)"
        activeCtx.lineWidth = Number(this.lineWidth)+nagenawaWidth
        activeCtx.stroke(this)
        visibleCtx.delete(this)
        activeCtx.draw(this)
        console.log(
          this.id+"を Active にしました。"
        )
      }

      Path2D.prototype.writeTo = function(p1,p2){
        const x = midPoint(p1,p2)[0]
        const y = midPoint(p1,p2)[1]
        this.quadraticCurveTo(p1[0],p1[1],x,y)
      }


      // "DOMMatrix"のメソッド追加

      //DOMMatrixによるPathの変換
      Path2D.prototype.transformedByMatrix = function(matrix){
        let newpath = new Path2D()
        newpath.addPath(this,matrix)
        newpath.points= []
        if(this.points){
          for(let j=0;j<this.points.length;j++){
            const x= this.points[j][0]
            const y= this.points[j][1]
            let point = new DOMPoint(x,y)
            point = point.matrixTransform(matrix)
            newpath.points.push([point.x,point.y])
          }
        }
        const scale = Math.sqrt(matrix.det())
        newpath.strokeStyle = this.strokeStyle
        newpath.lineWidth = this.lineWidth*scale
        newpath.id = this.id
        
        return newpath
      }

      DOMMatrix.prototype.det = function(){
        return Math.abs(this.a*this.d-this.b*this.c)
      }







      //clipと画像処理による重なり検出→断念（原因不明)
      // backCtx.clearRect(0,0,width,height)
      // const emptyImage = backCtx.getImageData(0,0,width,height)

      // Path2D.prototype.surroundedBy = function(path){
      //   let kakomi = path;
      //   let kore = this;
      //   activeCtx.clip(kakomi)
      //   activeCtx.clearRect(0,0,width,height)
      //   const Image1 = activeCtx.getImageData(0,0,width,height)
      //   activeCtx.stroke(kore)
      //   const Image2 = activeCtx.getImageData(0,0,width,height)
      //   // visibleCtx.beginPath()
      //   // visibleCtx.rect(0,0,width,height)
      //   // visibleCtx.clip()
      //   // return Image1!==Image2
      //   return Image1!==Image2}

      //   visibleCtx.clearRect(0,0,width,height)
      //   visibleCtx.fillStyle = 'rgb(0,0,0)';
      //   visibleCtx.fillRect(0,0,width,height);
      //   for(let i= 0;i<visibleCtx.pathes.length;i++){
      //     activeCtx.clearRect(0,0,width,height)
      //     activeCtx.fillStyle = 'rgb(0,0,0)';
      //     activeCtx.fillRect(0,0,width,height);
      //     activeCtx.clip(path)
      //     const Image1 = activeCtx.getImageData(0,0,width,height)
      //     activeCtx.stroke(visibleCtx.pathes[i])
      //     const Image2 = activeCtx.getImageData(0,0,width,height)
      //     console.log(i +" : "+ Image1===Image2)
      //   }
          


      // visibleCtx.pathes[0].surroundedBy(visibleCtx.pathes[1])


      // Active解除

      function nonActiveAll() {
        uiCtx.clearRect(0,0,width,height)
        uiCtx.pathes = []
        if(activeCtx.pathes.length>0){
          for(let i=0;i<activeCtx.pathes.length;i++){
            const path = activeCtx.pathes[i]
            visibleCtx.draw(path)
          }
        }
        activeCtx.clearRect(0,0,width,height)
        activeCtx.pathes = []
        
      }



      // 変換UIの作成

      uiCtx.strokeStyle = ui2Ctx.strokeStyle = "white"
      uiCtx.fillStyle = ui2Ctx.fillStyle = "red"
      uiCtx.lineWidth = ui2Ctx.lineWidth = 1
      uiCtx.btnSize = ui2Ctx.btnSize = 15
      uiCtx.pathes =ui2Ctx.pathes = []

      function createTransformUi() {
        if(activeCtx.pathes.length!==0){
          let minX = activeCtx.pathes[0].points[0][0]
          let minY = activeCtx.pathes[0].points[0][1]
          let maxX = minX
          let maxY = minY
          for(let i=0;i<activeCtx.pathes.length;i++){
            for(let j=0;j<activeCtx.pathes[i].points.length;j++){
              minX =  Math.min(minX,activeCtx.pathes[i].points[j][0]-activeCtx.pathes[i].lineWidth/2-nagenawaWidth/2)
              minY =  Math.min(minY,activeCtx.pathes[i].points[j][1]-activeCtx.pathes[i].lineWidth/2-nagenawaWidth/2)
              maxX =  Math.max(maxX,activeCtx.pathes[i].points[j][0]+activeCtx.pathes[i].lineWidth/2+nagenawaWidth/2)
              maxY =  Math.max(maxY,activeCtx.pathes[i].points[j][1]+activeCtx.pathes[i].lineWidth/2+nagenawaWidth/2)
            }
          }
          const w = maxX-minX
          const h = maxY-minY
          uiCtx.btnSize = (w+h)/40
          center = midPoint([minX,minY],[maxX,maxY])
          //四角
          path = new Path2D()
          path.rect(minX,minY,w,h)
          // path.closePath()
          uiCtx.draw(path)
          //削除ボタン
          path = new Path2D()
          path.arc(minX,minY,uiCtx.btnSize*1.4,0,2*Math.PI)
          path.moveTo(minX-uiCtx.btnSize,minY-uiCtx.btnSize)
          path.lineTo(minX+uiCtx.btnSize,minY+uiCtx.btnSize)
          path.moveTo(minX-uiCtx.btnSize,minY+uiCtx.btnSize)
          path.lineTo(minX+uiCtx.btnSize,minY-uiCtx.btnSize)
          // path.closePath()
          uiCtx.draw(path)
          //回転ボタン
          path = new Path2D()
          path.arc(minX,maxY,uiCtx.btnSize,0,2*Math.PI)
          path.arc(minX,maxY,uiCtx.btnSize*2/3,0,2*Math.PI)
          path.arc(minX,maxY,uiCtx.btnSize*4/3,0,2*Math.PI)
          // path.closePath()
          uiCtx.draw(path)
          //伸縮ボタン
          path = new Path2D()
          path.rect(maxX,maxY,uiCtx.btnSize*2,uiCtx.btnSize*2)
          path.rect(maxX,maxY,uiCtx.btnSize*2/3,uiCtx.btnSize*2/3)
          path.rect(maxX,maxY,uiCtx.btnSize*4/3,uiCtx.btnSize*4/3)
          // path.closePath()
          uiCtx.draw(path)
          //複製ボタン
          path = new Path2D()
          path.arc(maxX,minY,uiCtx.btnSize,0,2*Math.PI)
          path.arc(maxX-uiCtx.btnSize/3,minY-uiCtx.btnSize/3,uiCtx.btnSize,0,2*Math.PI)
          path.arc(maxX+uiCtx.btnSize/3,minY+uiCtx.btnSize/3,uiCtx.btnSize,0,2*Math.PI)
          // path.closePath()
          uiCtx.draw(path)
          //センターアンカー
          path = new Path2D()
          path.arc(center[0],center[1],uiCtx.btnSize,0,2*Math.PI)
          path.moveTo(center[0],center[1]-uiCtx.btnSize/2)
          path.lineTo(center[0],center[1]+uiCtx.btnSize/2)
          path.moveTo(center[0]-uiCtx.btnSize/2,center[1])
          path.lineTo(center[0]+uiCtx.btnSize/2,center[1])
          // path.closePath()
          uiCtx.draw(path)
          console.log(minX + "," + minY + "," +maxX + "," +maxY+ "の変換UIを表示しました")
        }
      }






      // 端点補正と補正点の記録

      let hoseitenGroup =[] 

      function tenHosei(point){ 
        let hoseiPoint= point
        for(let i = 1; i<hoseitenGroup.length;i++){
          let d = distance(hoseiPoint,hoseitenGroup[i])
          if((d>0)&&(d<20)){
            // return [thisX,thisY]
            hoseiPoint = hoseitenGroup[i]
            break;
          }
          // console.log(thisX+","+thisY)
        }
        hoseitenGroup.push(hoseiPoint)
        return hoseiPoint
      }


      // あたり判定がある場所
      function atatterubasyo(){
        
        for(let k=0;k<visibleCtx.pathes.length;k++){
          for(let i=0;i<width;i+=10){
            for(let j=0;j<height;j+=10){
              if(backCtx.isPointInPath(deleteBtn,i,j-menuHeight)){
                visibleCtx.beginPath()
                visibleCtx.fillStyle ="yellow"
                visibleCtx.arc(i,j,5,0,2*Math.PI)
                visibleCtx.fill()
                visibleCtx.strokeStyle = colorPicker.value
              }
            }
          }
        }
        console.log("あたり判定がある場を所調べました")
      }



    </script>    
  </body>
</html>
